#!/usr/bin/env perl
use warnings;
use strict;
use File::Temp qw(tempdir);
use Bio::SeqIO;
use Bio::AlignIO;
use Bio::SimpleAlign;
use Bio::LocatableSeq;

my $ZCAT = 'gzip -f -d -c';

my(@Options, $verbose, $distant, $format, $symbol, $outfile);
setOptions();

@ARGV >= 2 or die "Please provide two or more FASTA contig files.";

$symbol eq 'dna' || length($symbol)==1 or die "--symbol must be a single character.";
$outfile or die "Please specify an --outfile";

my $tool = $distant ? 'promer' : 'nucmer';
my($aligner) = qx(which $tool);
$aligner or die "Can not find '$tool'. Please install the MUMmer package.";
chomp $aligner;
print STDERR "Found $tool: $aligner\n";

my($showsnps) = qx(which show-snps);
$showsnps or die "Can not find 'showsnps'. Please install the MUMmer package.";
chomp $showsnps;
print STDERR "Found show-snps: $showsnps\n";

my $dir = tempdir(CLEANUP=>1);
#my $dir = 'tmp'; system("mkdir $dir");
print STDERR "Using temporary folder: $dir\n";

my $ref = shift @ARGV;
-r $ref or die "Can not read reference genome file: $ref";
print STDERR "Loading reference genome: $ref\n";
my $refdna;
my $in = Bio::SeqIO->new(-file=>"$ZCAT \Q$ref\E |", -format=>'fasta');
while (my $seq = $in->next_seq) {
  $refdna .= lc $seq->seq;
}
my $len = length($refdna);
print STDERR "Found $len bp\n";
my @is_snp;

my $ccref = "$dir/ccref.fasta";
print STDERR "Writing concatenated reference: $ccref\n";
my $ccref_out = Bio::SeqIO->new(-file=>">$ccref", -format=>'fasta');
$ccref_out->write_seq( Bio::Seq->new(-seq=>$refdna, -id=>'reference') );

print STDERR "Adding reference to alignment.\n";
my $aln = Bio::SimpleAlign->new(-source=>'scapper');
$aln->id('scapper');
$aln->add_seq( 
  Bio::LocatableSeq->new(-seq=>$refdna, -id=>$ref, -start=>1, -end=>$len) 
);

my @rest = @ARGV;
printf STDERR "Comparing to %d other genomes.\n", scalar(@rest);

my $id = 1;
for my $fname (@rest) {
  -r $fname or die "Can not read file: $fname";
  printf STDERR "[%d/%d]\t$fname\n", $id, 0+@rest;

  print STDERR "\tMaking decompressed copy of $fname...\n";
  my $fasta = "$dir/$id.fasta";
  system("$ZCAT \Q$fname\E > \Q$fasta\E");
  print STDERR "\tAligning with $tool... ";
  system("$aligner -p \Q$dir/$id\E \Q$ccref\E \Q$fasta\E 2> /dev/null")==0 
    or die "Error running $aligner [returned $?]";
  my($nblocks) = qx(grep -c '>' '$dir/$id.delta');
  chomp $nblocks;
  print STDERR " found $nblocks blocks.\n";

  print STDERR "\tIdentifying SNPs...\n";
  system("$showsnps -C -I -r -T '$dir/$id.delta' > '$dir/$id.snps' 2> /dev/null")==0
    or die "Error running $showsnps [returned $?]";
 
  # show-snps output (TSV)
  # [P1]   [SUB] [SUB] [P2]  [BUFF] [DIST] [FRM] [TAGS]
  # 186628 T     A     20975 1      20975   1    1       SeqID1 SeqID2

  print STDERR "\tParsing SNPs... ";
  my $new = $refdna;  
  my $nsnps = 0;
  open SNPS, "$dir/$id.snps";
  while (<SNPS>) { 
    chomp;
    my @x = split m/\t/;
    next unless @x >= 10 and $x[0] =~ m/^\d+$/;
    my $pos = $x[0];
    substr $new, $pos-1, 1, uc($x[2]);  # replace base
    $is_snp[$pos]++;
    $nsnps++;
  }
  print STDERR " found $nsnps SNPs.\n";

  # show-coords -b -r -T out.delta
  # [S1] [E1] [S2] [E2] [LEN 1] [LEN 2] [% IDY] [TAGS]
  # 1 120 61614 61495 120 120 96.69 reference gi|486682440|gb|AIVE01000005.1|

  print STDERR "\tAppending to aligment...\n";


### need to do this OUTSIDE the loop
### so the $pos loop below can substr all the letters
  $aln->add_seq( 
    Bio::LocatableSeq->new(-seq=>$new, -id=>$fname, -start=>1, -end=>$len, -alphabet=>'dna') 
  );

  $id++;
}

for my $pos (1 .. $len) {
  if ($is_snp[$pos]) {
    print STDERR "SNP @ $pos\n" if $verbose;
  }
}

if ($symbol ne 'dna') {
  $symbol = substr $symbol, 0, 1;
  print STDERR "Replacing conserved DNA columns with '$symbol'\n";
  $aln->map_chars('[actg]', $symbol);
}

print STDERR "Writing final $format alignment to $outfile ...\n";
my $out = Bio::AlignIO->new(-file=>">$outfile", -format=>$format);
$out->write_aln($aln);

print STDERR "Cleaning up.\n";

print STDERR "Done.\n";

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             
      DESC=>"This help"},
    {OPT=>"verbose!",  VAR=>\$verbose, DEFAULT=>0, 
      DESC=>"Verbose output"},
    {OPT=>"distant!",  VAR=>\$distant, DEFAULT=>0, 
      DESC=>"Genomes are distant: use promer not nucmer"},
    {OPT=>"format=s",  VAR=>\$format, DEFAULT=>'fasta', 
      DESC=>"Output alignment format: fasta nexus stockholm clustalw phylip mega ..."},
    {OPT=>"outfile=s",  VAR=>\$outfile, DEFAULT=>'/dev/stdout', 
      DESC=>"Output file"},
    {OPT=>"symbols=s",  VAR=>\$symbol, DEFAULT=>'dna', 
      DESC=>"What to put in conserved columns. Try: '-' or ' ' or 'N' or 'X'"},
  );

  (!@ARGV) && (usage());

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options] {reference.fa genome1.fa ...} > genomes.aln\n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------
